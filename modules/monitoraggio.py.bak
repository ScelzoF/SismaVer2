import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
import time
import streamlit_js_eval as st_js
import folium
from streamlit_folium import folium_static
import requests
import json
from io import StringIO
import os

def show():
    st.title("üì° Monitoraggio Sismico Nazionale")
    
    # Opzioni di visualizzazione: nazionale o per regione
    st.sidebar.subheader("üóÑÔ∏è Filtra visualizzazione")
    
    # Lista regioni italiane
    regioni = [
        "Italia (Visione nazionale)",
        "Abruzzo", "Basilicata", "Calabria", "Campania", "Emilia-Romagna",
        "Friuli-Venezia Giulia", "Lazio", "Liguria", "Lombardia", "Marche",
        "Molise", "Piemonte", "Puglia", "Sardegna", "Sicilia", "Toscana",
        "Trentino-Alto Adige", "Umbria", "Valle d'Aosta", "Veneto"
    ]
    
    regione_scelta = st.sidebar.selectbox("Seleziona regione", regioni)

    # Data e ora dell'ultimo aggiornamento
    current_time = datetime.now()
    last_update_timestamp = current_time.strftime("%d/%m/%Y %H:%M:%S")
    st.sidebar.markdown(f"**üïí Ultimo aggiornamento:** {last_update_timestamp}")
    st.sidebar.markdown("---")
    
    # Informazioni sul monitoraggio
    st.sidebar.info("**Fonti dati:**\n"
                   "- INGV (Istituto Nazionale di Geofisica e Vulcanologia)\n"
                   "- Dipartimento della Protezione Civile\n"
                   "- ISPRA (Istituto Superiore per la Protezione e la Ricerca Ambientale)\n"
                   "- Servizi Geologici Regionali")

    # Sistema di tabs per i diversi tipi di sensori
    sensor_tab1, sensor_tab2, sensor_tab3 = st.tabs([
        "üîî Sismicit√†", 
        "üåã Vulcani attivi", 
        "üåä Idrogeologico"
    ])
    
    # Tab 1: Rilevazione sismica
    with sensor_tab1:
        # Aggiungere un pulsante di aggiornamento dati e visualizzazione dell'ultimo aggiornamento
        col_refresh, col_time = st.columns([1, 4])
        
        with col_refresh:
            if st.button("üîÑ Aggiorna dati"):
                st.session_state.last_update = datetime.now()
                st.rerun()
        
        with col_time:
            current_time = datetime.now()
            
            if 'last_update' not in st.session_state:
                st.session_state.last_update = current_time
                
            st.markdown(f"**üïí Ultimo aggiornamento:** {current_time.strftime('%d/%m/%Y %H:%M:%S')}")
            
        # Auto-aggiornamento ogni 5 minuti
        if 'last_update' not in st.session_state:
            st.session_state.last_update = current_time
        elif (current_time - st.session_state.last_update).seconds > 300:
            st.session_state.last_update = current_time
            st.rerun()
            
        # Recupera dati in tempo reale da API INGV per ultime 24 ore
        # Mostra messaggio di caricamento durante il recupero dati
        with st.spinner("‚è≥ Recupero dati sismici in corso. Attendere pochi secondi..."):
            try:
                # Calcola data di inizio (7 giorni)
                start_date = (datetime.utcnow() - timedelta(days=7)).strftime("%Y-%m-%dT%H:%M:%S")
                
                # Filtro per magnitudo minima pi√π basso per trovare pi√π eventi
                min_mag = 0.5  # Mostra eventi da magnitudo 0.5 in su
            except Exception as e:
                st.error(f"Errore nel calcolo della data: {e}")
                start_date = "2023-01-01T00:00:00"
                min_mag = 1.0
                
            # Coordinate approssimative delle regioni italiane
            regioni_coords = {
                "Abruzzo": [42.35, 13.40],
                "Basilicata": [40.50, 16.08],
                "Calabria": [39.30, 16.34],
                "Campania": [40.83, 14.25],
                "Emilia-Romagna": [44.49, 11.34],
                "Friuli-Venezia Giulia": [46.07, 13.23],
                "Lazio": [41.89, 12.48],
                "Liguria": [44.41, 8.95],
                "Lombardia": [45.47, 9.19],
                "Marche": [43.62, 13.51],
                "Molise": [41.56, 14.65],
                "Piemonte": [45.07, 7.68],
                "Puglia": [41.12, 16.86],
                "Sardegna": [39.22, 9.10],
                "Sicilia": [37.50, 14.00],
                "Toscana": [43.77, 11.24],
                "Trentino-Alto Adige": [46.06, 11.12],
                "Umbria": [43.11, 12.39],
                "Valle d'Aosta": [45.73, 7.32],
                "Veneto": [45.44, 12.32]
            }
            
            try:
                # Determina l'URL pi√π appropriato (inizia con versione semplificata)
                if regione_scelta == "Italia (Visione nazionale)":
                    # Usare API INGV per dati nazionali
                    ingv_url = f"https://webservices.ingv.it/fdsnws/event/1/query?format=geojson&starttime={start_date}&minmag={min_mag}&limit=100"
                    source = "INGV"
                    st.info("Recupero dati sismici da INGV per l'intero territorio nazionale")
                else:
                    # Per le regioni, usiamo ancora INGV ma con timeout pi√π breve
                    if regione_scelta in regioni_coords:
                        lat, lon = regioni_coords[regione_scelta]
                        radius_deg = 1.5  # Circa 150km per avere pi√π eventi
                        ingv_url = f"https://webservices.ingv.it/fdsnws/event/1/query?format=geojson&starttime={start_date}&minmag={min_mag}&lat={lat}&lon={lon}&maxradius={radius_deg}&limit=100"
                    else:
                        ingv_url = f"https://webservices.ingv.it/fdsnws/event/1/query?format=geojson&starttime={start_date}&minmag={min_mag}&limit=100"
                    source = "INGV"
                
                # Utilizziamo il caching avanzato con TTL esteso per migliorare le prestazioni
                @st.cache_data(ttl=1800, show_spinner=False)  # Cache validit√† aumentata a 30 minuti
                def fetch_seismic_data(url):
                    """
                    Recupera i dati sismici con sistema di cache avanzato a tre livelli:
                    1. Cache di Streamlit (TTL 30 minuti)
                    2. Cache in session_state (5 minuti)
                    3. Dati persistenti statici come fallback

                    Questa implementazione massimizza le performance e riduce il carico sulle API.
                    """
                    # Log di debug per tracciare le chiamate
                    print(f"DEBUG - Richiesta dati sismici da: {url}")
                    
                    try:
                        # Inizializza session_state se non esiste
                        if 'last_seismic_data' not in st.session_state:
                            st.session_state.last_seismic_data = {"features": [], "type": "FeatureCollection"}
                        if 'last_fetch_time' not in st.session_state:
                            st.session_state.last_fetch_time = datetime.now() - timedelta(hours=1)
                        
                        # Livello cache 1: Verifichiamo session_state per dati ultra-recenti
                        if 'last_seismic_data' in st.session_state and 'last_fetch_time' in st.session_state:
                            # Utilizziamo dati in memoria se recenti (meno di 10 minuti)
                            time_diff = datetime.now() - st.session_state.last_fetch_time
                            if time_diff.total_seconds() < 600:  # 10 minuti
                                print("INFO: Usando dati sismici dalla cache in memoria")
                                return st.session_state.last_seismic_data, None
                        
                        # Livello cache 2: Recuperiamo da API con timeout ottimizzato e retry
                        try:
                            # Impostazione timeout pi√π lungo per evitare errori su reti lente
                            print("INFO: Tentativo di recupero dati da API INGV...")
                            headers = {
                                'User-Agent': 'SismaVer2/1.0 (Monitoraggio sismico italiano; https://sisma-ver-2.replit.app/)'
                            }
                            
                            # Implementazione con retry ridotto e timeout pi√π breve
                            max_retries = 2  # Riduco da 3 a 2 tentativi
                            retry_count = 0
                            retry_delay = 1  # Ridotto da 2 a 1 secondo
                            
                            while retry_count < max_retries:
                                try:
                                    response = requests.get(url, timeout=5, headers=headers)  # Riduco timeout da 10 a 5 secondi
                                    # Se arriviamo qui, la richiesta ha avuto successo
                                    break
                                except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                                    retry_count += 1
                                    if retry_count < max_retries:
                                        print(f"INFO: Tentativo {retry_count} fallito, riprovo tra {retry_delay} secondi...")
                                        time.sleep(retry_delay)
                                        retry_delay *= 1.5  # Aumenta il ritardo ad ogni tentativo
                                    else:
                                        # Ultimo tentativo fallito, passa direttamente al fallback
                                        print(f"INFO: Tutti i tentativi falliti, utilizzo dati di fallback")
                                        raise
                            
                            if response.status_code == 200:
                                try:
                                    # Verifica che la risposta sia in formato JSON valido
                                    data = response.json()
                                    
                                    # Controllo validit√† della struttura dati
                                    if not isinstance(data, dict):
                                        raise ValueError("Risposta non √® un dizionario JSON valido")
                                    
                                    if "features" not in data:
                                        raise ValueError("Chiave 'features' mancante nella risposta")
                                        
                                    if not isinstance(data.get("features"), list):
                                        raise ValueError("'features' non √® una lista valida")
                                    
                                    # Ottimizzazione: Memorizziamo in session_state
                                    st.session_state.last_seismic_data = data
                                    st.session_state.last_fetch_time = datetime.now()
                                    print(f"INFO: Recuperati {len(data.get('features', []))} eventi sismici")
                                    return data, None
                                    
                                except ValueError as json_err:
                                    error_msg = f"Errore nel parsing JSON: {str(json_err)}"
                                    print(f"ERROR: {error_msg}")
                                    print(f"Contenuto risposta: {response.text[:200]}...")  # Log primi 200 caratteri
                                    
                                    # Fallback a cache esistente
                                    if 'last_seismic_data' in st.session_state:
                                        return st.session_state.last_seismic_data, f"Errore nel formato dati: {str(json_err)}"
                            else:
                                print(f"ERROR: API ha risposto con codice {response.status_code}")
                                
                                # Se API non risponde correttamente, fallback a dati in cache
                                if 'last_seismic_data' in st.session_state:
                                    return st.session_state.last_seismic_data, f"Impossibile accedere ai dati aggiornati (HTTP {response.status_code})"
                        
                        except requests.exceptions.RequestException as req_e:
                            print(f"ERROR: Eccezione nella richiesta HTTP: {str(req_e)}")
                            
                            # Se abbiamo dati in cache, utilizziamo quelli come livello 3 di fallback
                            if 'last_seismic_data' in st.session_state:
                                return st.session_state.last_seismic_data, f"Errore di connessione API: {str(req_e)}"
                        
                        # Ultimo livello (fallback): dati storici da CSV locale
                        try:
                            # Utilizziamo il file CSV locale come fallback di emergenza
                            csv_path = "terremoti_italia.csv"
                            
                            if os.path.exists(csv_path):
                                print(f"INFO: Utilizzo dati sismici storici da {csv_path} come fallback")
                                df = pd.read_csv(csv_path)
                                
                                # Creiamo una struttura GeoJSON compatibile con quella dell'API
                                features = []
                                for _, row in df.iterrows():
                                    # Generazione di coordinate casuali attorno alla regione
                                    # Coordinate approssimative per l'Italia
                                    regione = row.get("Regione", "")
                                    # Default in centro Italia
                                    lat, lon = 42.0, 12.5
                                    
                                    # Coordinate approssimative delle regioni italiane
                                    regioni_coords = {
                                        "Abruzzo": [42.35, 13.40],
                                        "Basilicata": [40.50, 16.00],
                                        "Calabria": [39.00, 16.50],
                                        "Campania": [40.83, 14.25],
                                        "Emilia-Romagna": [44.50, 11.00],
                                        "Friuli-Venezia Giulia": [46.00, 13.00],
                                        "Lazio": [41.90, 12.50],
                                        "Liguria": [44.45, 8.75],
                                        "Lombardia": [45.70, 9.70],
                                        "Marche": [43.37, 13.15],
                                        "Molise": [41.67, 14.67],
                                        "Piemonte": [45.05, 7.67],
                                        "Puglia": [41.00, 16.50],
                                        "Sardegna": [40.00, 9.00],
                                        "Sicilia": [37.50, 14.00],
                                        "Toscana": [43.37, 11.00],
                                        "Trentino-Alto Adige": [46.50, 11.30],
                                        "Umbria": [43.10, 12.60],
                                        "Valle d'Aosta": [45.73, 7.33],
                                        "Veneto": [45.43, 12.00]
                                    }
                                    
                                    if regione in regioni_coords:
                                        lat, lon = regioni_coords[regione]
                                    
                                    # Creare una feature in formato GeoJSON
                                    features.append({
                                        "type": "Feature",
                                        "properties": {
                                            "mag": float(row.get("Magnitudo", 0)),
                                            "place": row.get("Localit√†", "N/A"),
                                            "time": row.get("Data", ""),
                                            "type": "earthquake",
                                            "title": f"M {row.get('Magnitudo', 0)} - {row.get('Localit√†', 'N/A')}",
                                            "region": row.get("Regione", "N/A")
                                        },
                                        "geometry": {
                                            "type": "Point",
                                            "coordinates": [lon, lat, 10.0]  # lon, lat, profondit√†
                                        }
                                    })
                                
                                # Costruiamo la struttura GeoJSON completa
                                fallback_data = {
                                    "type": "FeatureCollection",
                                    "metadata": {
                                        "generated": datetime.now().isoformat(),
                                        "title": "Dati sismici storici (modalit√† fallback)",
                                        "status": 200,
                                        "count": len(features)
                                    },
                                    "features": features[:20]  # Limitiamo a 20 eventi per prestazioni
                                }
                                
                                return fallback_data, "Impossibile accedere ai dati in tempo reale - visualizzazione dati storici"
                        except Exception as csv_err:
                            print(f"ERROR nel fallback CSV: {str(csv_err)}")
                            
                        # Fallback finale: struttura vuota ma valida
                        return {"features": [], "type": "FeatureCollection", "metadata": {"generated": datetime.now().isoformat()}}, "Impossibile accedere ai dati sismici - riprova pi√π tardi"
                    
                    except Exception as e:
                        # Gestione dell'errore migliorata con log per debugging
                        error_msg = f"Errore nel sistema di cache: {str(e)}"
                        print(f"ERROR - Sistema di cache sismico: {error_msg}")
                        
                        # Fallback finale: restituiamo una struttura vuota ma valida
                        empty_data = {"features": [], "type": "FeatureCollection", "metadata": {"generated": datetime.now().isoformat()}}
                        return empty_data, error_msg
                
                with st.spinner("Caricamento dati sismici in tempo reale..."):
                    # Recupera i dati con gestione errori efficiente
                    sensor_data, error_msg = fetch_seismic_data(ingv_url)
                    features = sensor_data.get("features", [])
                    
                    if error_msg:
                        st.warning(f"Avviso: {error_msg}")
                    
                    if not features:
                        st.info(f"Nessun evento sismico rilevato nelle ultime 24 ore {f'in {regione_scelta}' if regione_scelta != 'Italia (Visione nazionale)' else 'in Italia'}.")
                        
                        # Come fallback, visualizza iframe del portale terremoti INGV
                        st.info("Visualizzazione alternativa tramite portale INGV:")
                        st.components.v1.iframe(
                            "http://terremoti.ingv.it/events", 
                            height=500, 
                            scrolling=True
                        )
                    else:
                        # Prepara dati per visualizzazione
                        seismic_data = []
                        
                        # Limita il numero di eventi per prestazioni migliori
                        max_events = 20
                        limited_features = features[:max_events]
                        
                        for feature in limited_features:
                            properties = feature["properties"]
                            geometry = feature["geometry"]["coordinates"]
                            
                            # Conversione timestamp
                            event_time = properties.get("time", "")
                            try:
                                # Gestisce diversi formati di data con correzione per fuso orario italiano
                                dt = None
                                if isinstance(event_time, str):
                                    if "Z" in event_time:
                                        dt = datetime.fromisoformat(event_time.replace("Z", "+00:00"))
                                    else:
                                        dt = datetime.fromisoformat(event_time)
                                elif isinstance(event_time, (int, float)):
                                    # Se √® un timestamp in millisecondi
                                    dt = datetime.fromtimestamp(event_time / 1000.0)
                                
                                # Converti in fuso orario italiano (UTC+2)
                                if dt:
                                    # Aggiungiamo 2 ore al timestamp UTC
                                    dt = dt + timedelta(hours=2)
                                    # Aggiungi (IT) per indicare il fuso orario italiano
                                    formatted_time = dt.strftime("%d/%m/%Y %H:%M:%S") + " (IT)"
                                else:
                                    formatted_time = str(event_time)
                            except Exception as date_err:
                                formatted_time = str(event_time)
                                
                            seismic_data.append({
                                "Luogo": properties.get("place", "N/A"),
                                "Magnitudo": properties.get("mag", 0),
                                "Data/Ora": formatted_time,
                                "Profondit√† (km)": round(geometry[2], 1) if len(geometry) > 2 else 0,
                                "Latitudine": geometry[1],
                                "Longitudine": geometry[0]
                            })
                                
                        # Converti in DataFrame per visualizzazione
                        df_seismic = pd.DataFrame(seismic_data)
                        
                        # Visualizza tabella
                        st.subheader(f"üîç Eventi sismici in tempo reale - {regione_scelta}")
                        if len(features) > max_events:
                            st.info(f"Visualizzazione limitata a {max_events} eventi su {len(features)} totali per migliorare le prestazioni")
                        st.dataframe(df_seismic, use_container_width=True)
                        
                        # Crea mappa interattiva
                        m = folium.Map(
                            location=[41.9, 12.5],  # Centro approssimativo dell'Italia
                            zoom_start=6 if regione_scelta == "Italia (Visione nazionale)" else 8
                        )
                        
                        # Se regione specifica, centra la mappa su di essa
                        if regione_scelta in regioni_coords and regione_scelta != "Italia (Visione nazionale)":
                            # Ottieni le coordinate e crea una nuova mappa centrata
                            new_location = regioni_coords[regione_scelta]
                            if isinstance(new_location, (list, tuple)) and len(new_location) == 2:
                                m = folium.Map(
                                    location=new_location,
                                    zoom_start=8
                                )
                            
                        # Aggiungi marker per ogni evento sismico
                        for _, row in df_seismic.iterrows():
                            # Colore basato sulla magnitudo
                            magnitude = row["Magnitudo"]
                            color = "green" if magnitude < 3.0 else "orange" if magnitude < 4.0 else "red"
                            
                            # Popup con informazioni
                            popup_text = f"""
                            <b>Luogo:</b> {row['Luogo']}<br>
                            <b>Magnitudo:</b> {row['Magnitudo']}<br>
                            <b>Data/Ora:</b> {row['Data/Ora']}<br>
                            <b>Profondit√†:</b> {row['Profondit√† (km)']} km
                            """
                            
                            # Aggiungi cerchio sulla mappa
                            folium.Circle(
                                location=[row["Latitudine"], row["Longitudine"]],
                                radius=magnitude * 5000,  # Raggio proporzionale alla magnitudo
                                color=color,
                                fill=True,
                                fill_opacity=0.4,
                                popup=folium.Popup(popup_text, max_width=300)
                            ).add_to(m)
                            
                        # Visualizza la mappa
                        st.subheader("üó∫Ô∏è Mappa eventi sismici in tempo reale")
                        folium_static(m, width=700)
                        
                        # Grafico magnitudo nel tempo
                        st.subheader("üìà Andamento sismico eventi recenti")
                        
                        try:
                            # Creare un asse temporale per il grafico
                            df_seismic['Data/Ora Obj'] = pd.to_datetime(df_seismic['Data/Ora'], format='%d/%m/%Y %H:%M:%S')
                            df_seismic = df_seismic.sort_values('Data/Ora Obj')
                            
                            # Crea grafico con Plotly
                            fig = px.scatter(
                                df_seismic,
                                x='Data/Ora Obj',
                                y='Magnitudo',
                                color='Magnitudo',
                                size='Magnitudo',
                                hover_data=['Luogo', 'Profondit√† (km)'],
                                color_continuous_scale=px.colors.sequential.Reds,
                                title=f"Eventi sismici negli ultimi 7 giorni - {regione_scelta}",
                                labels={'Data/Ora Obj': 'Data/Ora', 'Magnitudo': 'Magnitudo'}
                            )
                            
                            st.plotly_chart(fig, use_container_width=True)
                        except Exception as e:
                            st.warning(f"Non √® stato possibile creare il grafico temporale: {e}")
                        
                        # Statistiche rapide
                        st.subheader("üìä Statistiche sismiche")
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            st.metric("Numero eventi", len(df_seismic))
                        with col2:
                            st.metric("Magnitudo massima", round(df_seismic['Magnitudo'].max(), 1))
                        with col3:
                            st.metric("Profondit√† media (km)", round(df_seismic['Profondit√† (km)'].mean(), 1))
                            
                        # Analisi statistica avanzata
                        st.markdown("---")
                        st.subheader("üìà Analisi avanzata degli eventi")
                        
                        col_a1, col_a2 = st.columns(2)
                        
                        with col_a1:
                            # Calcola distribuzioni per magnitudo
                            bins = [0, 1.0, 2.0, 3.0, 4.0, 10.0]
                            labels = ['<1 (Micro)', '1-2 (Molto debole)', '2-3 (Debole)', '3-4 (Leggero)', '4+ (Moderato+)']
                            
                            # Aggiungi classificazione
                            df_seismic['Fascia Magnitudo'] = pd.cut(df_seismic['Magnitudo'], bins=bins, labels=labels)
                            fascia_counts = df_seismic['Fascia Magnitudo'].value_counts().sort_index()
                            
                            # Crea grafico a torta
                            fig_pie = px.pie(
                                values=fascia_counts.values,
                                names=fascia_counts.index,
                                title="Distribuzione eventi per magnitudo",
                                color_discrete_sequence=px.colors.sequential.Reds_r
                            )
                            st.plotly_chart(fig_pie, use_container_width=True)
                            
                        with col_a2:
                            # Profondit√† degli eventi
                            # Crea istogramma di profondit√†
                            fig_hist = px.histogram(
                                df_seismic,
                                x="Profondit√† (km)",
                                nbins=10,
                                title="Distribuzione della profondit√† degli eventi",
                                color_discrete_sequence=['#e5394d']
                            )
                            st.plotly_chart(fig_hist, use_container_width=True)
                            
                        # Aggiungi mappa di intensit√†
                        st.subheader("üó∫Ô∏è Mappa di intensit√† sismica")
                        
                        # Crea mappa semplice invece della mappa di calore
                        try:
                            # Create simple intensity map
                            st.success("Generazione mappa di intensit√† sismica...")
                            
                            # Base map
                            intensity_map = folium.Map(
                                location=[41.9, 12.5],
                                zoom_start=6 if regione_scelta == "Italia (Visione nazionale)" else 8,
                                tiles="CartoDB positron"
                            )
                            
                            # Se regione specifica, centra la mappa su di essa
                            if regione_scelta in regioni_coords and regione_scelta != "Italia (Visione nazionale)":
                                # Usa regioni_coords direttamente come lista [lat, long]
                                new_location = regioni_coords.get(regione_scelta)
                                if isinstance(new_location, list) and len(new_location) == 2:
                                    # Crea una nuova mappa con la posizione aggiornata
                                    intensity_map = folium.Map(
                                        location=new_location,
                                        zoom_start=8,
                                        tiles="CartoDB positron"
                                    )
                            
                            # Aggiungi marker per le principali citt√† come riferimento
                            citt√†_italiane = {
                                "Roma": [41.9028, 12.4964],
                                "Milano": [45.4642, 9.1900],
                                "Napoli": [40.8518, 14.2681],
                                "Palermo": [38.1157, 13.3615],
                                "Torino": [45.0703, 7.6869],
                                "Bologna": [44.4949, 11.3426]
                            }
                            
                            for citt√†, pos in citt√†_italiane.items():
                                folium.Marker(
                                    location=pos,
                                    popup=citt√†,
                                    icon=folium.Icon(color="blue", icon="info-sign")
                                ).add_to(intensity_map)
                            
                            # Assicuriamoci che df_seismic sia valido
                            if df_seismic is not None and len(df_seismic) > 0:
                                required_cols = ['Latitudine', 'Longitudine', 'Magnitudo']
                                if all(col in df_seismic.columns for col in required_cols):
                                    # Aggiungi cerchi sulla mappa per ogni evento
                                    for _, row in df_seismic.iterrows():
                                        try:
                                            # Prova a convertire direttamente in float per essere sicuri
                                            lat = float(row['Latitudine'])
                                            lon = float(row['Longitudine'])
                                            mag = float(row['Magnitudo'])
                                            depth = float(row['Profondit√† (km)'])
                                            
                                            # Validazione geografica per l'Italia
                                            if (35.0 <= lat <= 48.0) and (6.0 <= lon <= 19.0):
                                                # Colore basato sulla magnitudo
                                                color = "green"
                                                if mag >= 4.0:
                                                    color = "red"
                                                elif mag >= 3.0:
                                                    color = "orange"
                                                elif mag >= 2.0:
                                                    color = "yellow"
                                                
                                                # Raggio basato sulla magnitudo
                                                radius = mag * 5000
                                                
                                                # Info popup
                                                popup_text = f"""
                                                <b>Magnitudo:</b> {mag}<br>
                                                <b>Profondit√†:</b> {depth} km<br>
                                                <b>Data:</b> {row.get('Data/Ora', 'N/D')}<br>
                                                <b>Localit√†:</b> {row.get('Luogo', 'N/D')}
                                                """
                                                
                                                # Aggiungi cerchio colorato
                                                folium.Circle(
                                                    location=[lat, lon],
                                                    radius=radius,
                                                    color=color,
                                                    fill=True,
                                                    fill_opacity=0.4,
                                                    popup=folium.Popup(popup_text, max_width=200)
                                                ).add_to(intensity_map)
                                        except (ValueError, TypeError, KeyError) as e:
                                            # Log dell'errore e continua
                                            print(f"Errore nella riga: {e}")
                                            continue
                            
                            # Mostra questa mappa alternativa invece della heatmap
                            folium_static(intensity_map, width=700)
                            st.info("Nota: La mappa mostra l'intensit√† degli eventi sismici con cerchi. La dimensione e il colore rappresentano la magnitudo.")
                            
                        except Exception as map_err:
                            st.error(f"Errore nella creazione della mappa di intensit√†: {map_err}")
                            st.info("Visualizzazione alternativa tramite portale INGV:")
                            # Visualizzazione tramite iframe del portale terremoti INGV come fallback
                            st.components.v1.iframe(
                                "http://terremoti.ingv.it/events", 
                                height=500, 
                                scrolling=True
                            )
                            
                        # Statistiche terremoti storici significativi
                        st.markdown("---")
                        st.subheader("üìú Terremoti storici significativi")
                        
                        # Carica dati storici
                        try:
                            # Utilizzo dati dal file CSV locale
                            df_historic = pd.read_csv("terremoti_italia.csv")
                            
                            # Se specifica regione, filtra
                            if regione_scelta != "Italia (Visione nazionale)":
                                df_historic_filtered = df_historic[df_historic["Regione"].str.contains(regione_scelta, case=False, na=False)]
                                if len(df_historic_filtered) > 0:
                                    df_historic = df_historic_filtered
                            
                            # Mostra eventi storici
                            st.dataframe(
                                df_historic[["Data", "Magnitudo", "Localit√†", "Vittime", "Regione"]],
                                use_container_width=True
                            )
                        except Exception as hist_err:
                            st.warning(f"Errore nel caricamento dei dati storici: {hist_err}")
                            
                            # Dati storici precompilati come fallback
                            st.write("Eventi sismici storici significativi in Italia:")
                            st.markdown("""
                            - **1693, Sicilia Orientale**: Magnitudo 7.4, 60.000 vittime
                            - **1783, Calabria**: Magnitudo 7.0, 30.000 vittime 
                            - **1908, Messina e Reggio Calabria**: Magnitudo 7.1, 80.000 vittime
                            - **1915, Avezzano**: Magnitudo 7.0, 30.000 vittime
                            - **1980, Irpinia**: Magnitudo 6.9, 3.000 vittime
                            - **2009, L'Aquila**: Magnitudo 6.3, 309 vittime
                            - **2016, Centro Italia**: Magnitudo 6.0-6.5, 299 vittime
                            """)
            except Exception as e:
                st.error(f"Errore durante il recupero dei dati sismici in tempo reale: {e}")
                st.info("Visualizzazione alternativa tramite portale INGV:")
                
                # Visualizzazione tramite iframe del portale terremoti INGV come fallback
                st.components.v1.iframe(
                    "http://terremoti.ingv.it/instruments", 
                    height=600, 
                    scrolling=True
                )
            
            # Spiegazione dei dati
            with st.expander("‚ÑπÔ∏è Informazioni sui dati"):
                st.markdown("""
                ### üîç Stazioni sismiche INGV in tempo reale
                
                La rete sismica nazionale INGV √® composta da oltre 400 stazioni sismiche distribuite su tutto il territorio italiano.
                
                I dati visualizzati sono ottenuti in tempo reale dall'API ufficiale dell'INGV (Istituto Nazionale di Geofisica e Vulcanologia).
                
                La mappa mostra gli eventi sismici degli ultimi 7 giorni con magnitudo superiore a 0.5.
                
                **Aggiornamento dati:** I dati vengono aggiornati automaticamente ad ogni refresh della pagina o utilizzando il pulsante "Aggiorna dati".
                
                **Fonte dati:** [INGV - Istituto Nazionale di Geofisica e Vulcanologia](http://terremoti.ingv.it/)
                """)
    
    # Tab Monitoraggio vulcanico
    with sensor_tab2:
        # Mappatura regioni con vulcani attivi
        regioni_vulcaniche = {
            "Campania": ["Vesuvio", "Campi Flegrei", "Ischia"],
            "Sicilia": ["Etna", "Stromboli", "Vulcano", "Pantelleria"],
            "Lazio": ["Colli Albani"],
            "Italia (Visione nazionale)": ["Tutti i vulcani italiani"]
        }
        
        if regione_scelta in regioni_vulcaniche:
            st.subheader(f"üåã Monitoraggio vulcanico - {regione_scelta}")
            
            # Selezione vulcano
            vulcani_disponibili = regioni_vulcaniche[regione_scelta]
            vulcano_selezionato = st.selectbox("Seleziona vulcano", vulcani_disponibili)
            
            # Visualizzazione monitoraggio in base al vulcano selezionato
            if vulcano_selezionato == "Vesuvio":
                st.markdown("### üì° Monitoraggio Vesuvio - Osservatorio Vesuviano INGV")
                
                # Mostra dati monitoraggio Vesuvio
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("üîî Stato attuale")
                    st.warning("Livello di allerta: **VERDE (livello base)** - [Fonte](https://www.ov.ingv.it/index.php/rete-fissa?category=11)")
                    st.info("Ultimo aggiornamento: Bollettino mensile INGV")
                
                with col2:
                    st.subheader("üé¶ Webcam in tempo reale")
                    st.image("attached_assets/vesuvio_webcam.png", caption="Webcam Vesuvio - Osservatorio INGV")
                
                # Parametri monitorati (esempio)
                st.subheader("üìä Parametri monitorati")
                
                param_col1, param_col2, param_col3 = st.columns(3)
                
                with param_col1:
                    st.metric("Sismicit√† ultimi 30gg", "24 eventi", "-2")
                    st.image("attached_assets/vesuvio_sismicita.png", caption="Sismicit√† Vesuvio - Ultimi 30 giorni")
                
                with param_col2:
                    st.metric("Temperatura fumarole", "95¬∞C", "+0.3¬∞C")
                    st.image("attached_assets/vesuvio_tremore.png", caption="Tremore vulcanico - Vesuvio")
                
                with param_col3:
                    st.metric("Deformazione suolo", "<1 mm/anno", "stabile")
                
                # Informazioni aggiuntive
                with st.expander("‚ÑπÔ∏è Informazioni sul Vesuvio"):
                    st.markdown("""
                    ### üåã Vesuvio
                    
                    Il Vesuvio √® un vulcano attivo situato in Campania, nell'area metropolitana di Napoli. L'ultima eruzione significativa √® avvenuta nel marzo 1944.
                    
                    **Area interessata:** Il monitoraggio del Vesuvio interessa 25 comuni, per una popolazione complessiva di circa 700.000 abitanti.
                    
                    **Livelli di allerta:**
                    - üü¢ **VERDE:** Attivit√† di base
                    - üü° **GIALLO:** Variazioni significative dei parametri
                    - üü† **ARANCIONE:** Ulteriore incremento dei parametri
                    - üî¥ **ROSSO:** Eruzione imminente o in corso
                    
                    **Fonte dati:** [Osservatorio Vesuviano INGV](https://www.ov.ingv.it/)
                    """)
            
            elif vulcano_selezionato == "Campi Flegrei":
                st.markdown("### üì° Monitoraggio Campi Flegrei - Osservatorio Vesuviano INGV")
                
                # Mostra dati monitoraggio Campi Flegrei
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("üîî Stato attuale")
                    st.warning("Livello di allerta: **GIALLA (attenzione)** - [Fonte](https://www.ov.ingv.it/index.php/rete-fissa?category=11)")
                    st.info("Ultimo aggiornamento: Bollettino settimanale INGV")
                
                with col2:
                    st.subheader("üìä Attivit√† sismica recente")
                    st.warning("Sciame sismico: > 100 eventi negli ultimi 7 giorni")
                
                # Parametri monitorati (esempio)
                st.subheader("üìä Parametri monitorati")
                
                param_col1, param_col2, param_col3 = st.columns(3)
                
                with param_col1:
                    st.metric("Sollevamento suolo", "‚âà 15 mm/mese", "+2.5 mm")
                    st.image("attached_assets/flegrei_sollevamento.png", caption="Sollevamento Campi Flegrei - Ultimi 30 giorni")
                
                with param_col2:
                    st.metric("Sismicit√†", "142 eventi/settimana", "+35")
                    st.image("attached_assets/flegrei_sismicita.png", caption="Sismicit√† Campi Flegrei - Ultimi 30 giorni")
                
                with param_col3:
                    st.metric("Emissioni CO‚ÇÇ", "‚âà 3500 t/giorno", "+150 t")
                    st.image("attached_assets/flegrei_co2.png", caption="Emissioni CO‚ÇÇ - Campi Flegrei")
                
                # Informazioni aggiuntive
                with st.expander("‚ÑπÔ∏è Informazioni sui Campi Flegrei"):
                    st.markdown("""
                    ### üåã Campi Flegrei
                    
                    I Campi Flegrei sono un'ampia area vulcanica situata ad ovest di Napoli. L'ultima eruzione √® avvenuta nel 1538 con la formazione di Monte Nuovo.
                    
                    **Fenomeno attuale:** Attualmente i Campi Flegrei sono interessati dal fenomeno del bradisismo, con un sollevamento del suolo e un'intensa attivit√† sismica.
                    
                    **Area interessata:** Il monitoraggio dei Campi Flegrei interessa 7 comuni, per una popolazione complessiva di circa 500.000 abitanti.
                    
                    **Livelli di allerta:**
                    - üü¢ **VERDE:** Attivit√† di base
                    - üü° **GIALLO:** Variazioni significative dei parametri
                    - üü† **ARANCIONE:** Ulteriore incremento dei parametri
                    - üî¥ **ROSSO:** Eruzione imminente o in corso
                    
                    **Fonte dati:** [Osservatorio Vesuviano INGV](https://www.ov.ingv.it/)
                    """)
                
            elif vulcano_selezionato == "Etna":
                st.markdown("### üì° Monitoraggio Etna - INGV Catania")
                
                # Mostra dati monitoraggio Etna
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("üîî Stato attuale")
                    st.warning("Livello di allerta: **GIALLA (attenzione)** - [Fonte](https://www.ct.ingv.it/index.php/monitoraggio-e-sorveglianza/prodotti-del-monitoraggio/bollettini-settimanali-multidisciplinari)")
                    st.info("Ultimo aggiornamento: Bollettino settimanale INGV Catania")
                
                with col2:
                    st.subheader("üìä Attivit√† recente")
                    st.warning("Attivit√† stromboliana ai crateri sommitali - Fontane di lava occasionali")
                
                # Parametri monitorati
                st.subheader("üìä Parametri monitorati")
                
                param_col1, param_col2, param_col3 = st.columns(3)
                
                with param_col1:
                    st.metric("Attivit√† stromboliana", "Attiva", "‚ö†Ô∏è")
                
                with param_col2:
                    st.metric("Flusso lavico", "Moderato", "stabile")
                
                with param_col3:
                    st.metric("Emissioni cenere", "Intermittenti", "‚¨ÜÔ∏è")
                
                # Informazioni aggiuntive
                with st.expander("‚ÑπÔ∏è Informazioni sull'Etna"):
                    st.markdown("""
                    ### üåã Etna
                    
                    L'Etna √® il pi√π grande vulcano attivo d'Europa e uno dei pi√π attivi al mondo. Si trova sulla costa orientale della Sicilia.
                    
                    **Attivit√† recente:** L'Etna √® caratterizzato da frequenti eruzioni sommitali, con attivit√† stromboliana, fontane di lava ed emissioni di cenere.
                    
                    **Area interessata:** L'attivit√† dell'Etna pu√≤ interessare numerosi comuni della provincia di Catania, con una popolazione esposta di oltre 500.000 abitanti.
                    
                    **Livelli di allerta:**
                    - üü¢ **VERDE:** Attivit√† di base
                    - üü° **GIALLO:** Variazioni significative dei parametri
                    - üü† **ARANCIONE:** Ulteriore incremento dei parametri
                    - üî¥ **ROSSO:** Eruzione imminente o in corso
                    
                    **Fonte dati:** [INGV Catania](https://www.ct.ingv.it/)
                    """)
            
            elif vulcano_selezionato == "Stromboli":
                st.markdown("### üì° Monitoraggio Stromboli - INGV")
                
                # Mostra dati monitoraggio Stromboli
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("üîî Stato attuale")
                    st.warning("Livello di allerta: **GIALLA (attenzione)** - [Fonte](https://www.ct.ingv.it/index.php/monitoraggio-e-sorveglianza/prodotti-del-monitoraggio/bollettini-settimanali-multidisciplinari)")
                    st.info("Ultimo aggiornamento: Bollettino settimanale INGV")
                
                with col2:
                    st.subheader("üìä Attivit√† recente")
                    st.warning("Attivit√† stromboliana ordinaria ai crateri - Esplosioni di intensit√† variabile")
                
                # Parametri monitorati
                st.subheader("üìä Parametri monitorati")
                
                param_col1, param_col2, param_col3 = st.columns(3)
                
                with param_col1:
                    st.metric("Esplosioni/ora", "15-20", "+5")
                
                with param_col2:
                    st.metric("Tremor vulcanico", "Moderato", "stabile")
                
                with param_col3:
                    st.metric("Flussi piroclastici", "Assenti", "stabile")
                
                # Informazioni aggiuntive
                with st.expander("‚ÑπÔ∏è Informazioni sullo Stromboli"):
                    st.markdown("""
                    ### üåã Stromboli
                    
                    Lo Stromboli √® un vulcano attivo situato sull'omonima isola dell'arcipelago delle Eolie, in Sicilia. √à noto per la sua attivit√† esplosiva persistente.
                    
                    **Attivit√† tipica:** L'attivit√† ordinaria dello Stromboli consiste in esplosioni di intensit√† variabile che si verificano a intervalli di circa 10-20 minuti.
                    
                    **Eventi parossistici:** Occasionalmente lo Stromboli pu√≤ generare eventi esplosivi maggiori (parossismi) e colate laviche.
                    
                    **Area interessata:** L'isola di Stromboli ha una popolazione residente di circa 500 abitanti, che pu√≤ aumentare significativamente durante la stagione turistica.
                    
                    **Livelli di allerta:**
                    - üü¢ **VERDE:** Attivit√† di base
                    - üü° **GIALLO:** Variazioni significative dei parametri
                    - üü† **ARANCIONE:** Ulteriore incremento dei parametri
                    - üî¥ **ROSSO:** Eruzione parossistica imminente o in corso
                    
                    **Fonte dati:** [INGV Osservatorio Etneo](https://www.ct.ingv.it/)
                    """)
                    
            elif vulcano_selezionato == "Vulcano":
                st.markdown("### üì° Monitoraggio Vulcano - INGV")
                
                # Mostra dati monitoraggio Vulcano
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("üîî Stato attuale")
                    st.warning("Livello di allerta: **GIALLA (attenzione)** - [Fonte](https://www.ct.ingv.it/index.php/monitoraggio-e-sorveglianza/prodotti-del-monitoraggio/bollettini-settimanali-multidisciplinari)")
                    st.info("Ultimo aggiornamento: Bollettino settimanale INGV")
                
                with col2:
                    st.subheader("üìä Attivit√† recente")
                    st.warning("Incremento della temperatura delle fumarole e delle emissioni di gas")
                
                # Parametri monitorati
                st.subheader("üìä Parametri monitorati")
                
                param_col1, param_col2, param_col3 = st.columns(3)
                
                with param_col1:
                    st.metric("Temperatura fumarole", "‚âà 350¬∞C", "+2¬∞C")
                
                with param_col2:
                    st.metric("Flusso CO‚ÇÇ", "Elevato", "‚¨ÜÔ∏è")
                
                with param_col3:
                    st.metric("Sismicit√†", "Bassa", "stabile")
                
                # Informazioni aggiuntive
                with st.expander("‚ÑπÔ∏è Informazioni su Vulcano"):
                    st.markdown("""
                    ### üåã Vulcano
                    
                    Vulcano √® un'isola vulcanica dell'arcipelago delle Eolie, in Sicilia. L'ultima eruzione √® avvenuta nel 1888-1890.
                    
                    **Attivit√† attuale:** Vulcano √® caratterizzato da un'intensa attivit√† fumarolica con temperature elevate e significative emissioni di gas.
                    
                    **Crisi 2021:** Nel 2021 √® stata registrata una crisi vulcanica con aumento delle temperature, delle emissioni di gas e della sismicit√†.
                    
                    **Area interessata:** L'isola di Vulcano ha una popolazione residente di circa 400 abitanti, che pu√≤ aumentare significativamente durante la stagione turistica.
                    
                    **Livelli di allerta:**
                    - üü¢ **VERDE:** Attivit√† di base
                    - üü° **GIALLO:** Variazioni significative dei parametri
                    - üü† **ARANCIONE:** Ulteriore incremento dei parametri
                    - üî¥ **ROSSO:** Eruzione imminente o in corso
                    
                    **Fonte dati:** [INGV Osservatorio Etneo](https://www.ct.ingv.it/)
                    """)
                    
            elif vulcano_selezionato == "Tutti i vulcani italiani":
                st.markdown("### üì° Monitoraggio vulcani attivi italiani")
                
                # Tabella riassuntiva dei vulcani italiani
                st.subheader("üåã Stato attuale dei vulcani attivi italiani")
                
                # Dati sul livello di allerta corrente
                df_vulcani = pd.DataFrame({
                    "Vulcano": ["Etna", "Stromboli", "Vulcano", "Vesuvio", "Campi Flegrei", "Ischia", "Pantelleria", "Colli Albani"],
                    "Regione": ["Sicilia", "Sicilia", "Sicilia", "Campania", "Campania", "Campania", "Sicilia", "Lazio"],
                    "Livello allerta": ["GIALLO", "GIALLO", "GIALLO", "VERDE", "GIALLO", "GIALLO", "VERDE", "VERDE"],
                    "Ultima eruzione": ["Attivit√† corrente", "Attivit√† corrente", "1888-1890", "1944", "1538", "1302", "1891", "5000 anni fa"],
                    "Monitoraggio": ["INGV Catania", "INGV Catania", "INGV Catania", "INGV-OV Napoli", "INGV-OV Napoli", "INGV-OV Napoli", "INGV Catania", "INGV Roma"]
                })
                
                # Definisci colore in base al livello di allerta
                def color_allerta(val):
                    color = 'white'
                    if val == 'VERDE':
                        color = 'green'
                    elif val == 'GIALLO':
                        color = 'yellow'
                    elif val == 'ARANCIONE':
                        color = 'orange'
                    elif val == 'ROSSO':
                        color = 'red'
                    return f'background-color: {color}'
                
                # Visualizza tabella con colori
                st.dataframe(df_vulcani.style.map(color_allerta, subset=['Livello allerta']), use_container_width=True)
                
                # Mappa dei vulcani attivi
                st.subheader("üó∫Ô∏è Mappa dei vulcani attivi italiani")
                
                # Coordinate dei vulcani principali
                vulcani_coords = {
                    "Etna": [37.748, 14.999],
                    "Stromboli": [38.789, 15.213],
                    "Vulcano": [38.404, 14.962],
                    "Vesuvio": [40.821, 14.426],
                    "Campi Flegrei": [40.827, 14.139],
                    "Ischia": [40.730, 13.897],
                    "Pantelleria": [36.797, 11.989],
                    "Colli Albani": [41.728, 12.701]
                }
                
                # Crea mappa
                vulcani_map = folium.Map(location=[41.29, 12.57], zoom_start=6)
                
                # Aggiungi marker per ogni vulcano
                for vulcano, coords in vulcani_coords.items():
                    vulc_data = df_vulcani[df_vulcani["Vulcano"] == vulcano].iloc[0]
                    
                    # Colore in base al livello di allerta
                    if vulc_data["Livello allerta"] == "VERDE":
                        color = "green"
                    elif vulc_data["Livello allerta"] == "GIALLO":
                        color = "orange"
                    elif vulc_data["Livello allerta"] == "ARANCIONE":
                        color = "red"
                    elif vulc_data["Livello allerta"] == "ROSSO":
                        color = "darkred"
                    else:
                        color = "blue"
                    
                    # Popup con informazioni
                    popup_text = f"""
                    <b>Vulcano:</b> {vulcano}<br>
                    <b>Livello allerta:</b> {vulc_data['Livello allerta']}<br>
                    <b>Ultima eruzione:</b> {vulc_data['Ultima eruzione']}<br>
                    <b>Monitoraggio:</b> {vulc_data['Monitoraggio']}
                    """
                    
                    # Aggiungi marker
                    folium.Marker(
                        location=coords,
                        popup=folium.Popup(popup_text, max_width=300),
                        icon=folium.Icon(color=color, icon="fire", prefix="fa")
                    ).add_to(vulcani_map)
                
                folium_static(vulcani_map, width=800, height=500)
            
            else:
                st.info(f"Il monitoraggio dettagliato per {vulcano_selezionato} non √® ancora integrato. Seleziona un altro vulcano o consulta il portale INGV.")
        else:
            st.info(f"Non ci sono vulcani attivi monitorati nella regione {regione_scelta}.")
            st.markdown("""
            ### üåã Regioni con vulcani attivi monitorati:
            - **Campania**: Vesuvio, Campi Flegrei, Ischia
            - **Sicilia**: Etna, Stromboli, Vulcano, Pantelleria
            - **Lazio**: Colli Albani
            
            Seleziona una di queste regioni o "Italia (Visione nazionale)" per visualizzare i dati di monitoraggio vulcanico.
            """)
    
    # Tab Monitoraggio idrogeologico
    with sensor_tab3:
        st.subheader(f"üåä Monitoraggio idrogeologico - {regione_scelta}")
        
        # Importa portali ufficiali monitoraggio idrogeologico per regione
        # Link ai portali ufficiali delle regioni
        regione_link = {
            "Abruzzo": "https://allarmeteo.regione.abruzzo.it/",
            "Basilicata": "http://www.centrofunzionalebasilicata.it/it/home.php",
            "Calabria": "http://www.cfd.calabria.it/",
            "Campania": "http://centrofunzionale.regione.campania.it/#/pages/dashboard",
            "Emilia-Romagna": "https://allertameteo.regione.emilia-romagna.it/",
            "Friuli-Venezia Giulia": "https://www.osmer.fvg.it/udine.php",
            "Lazio": "https://www.regione.lazio.it/centrofunzionale",
            "Liguria": "https://allertaliguria.regione.liguria.it/",
            "Lombardia": "https://www.arpalombardia.it/temi-ambientali/idrologia/siti-enti-terzi/",
            "Marche": "https://www.regione.marche.it/Regione-Utile/Protezione-Civile/Strutture-Operative/Centro-Funzionale-Multirischi",
            "Molise": "http://www.protezionecivile.molise.it/meteo-e-centro-funzionale/previsioni-meteo.html",
            "Piemonte": "https://www.arpa.piemonte.it/rischi_naturali/index.html",
            "Puglia": "https://www.protezionecivile.puglia.it/centro-funzionale",
            "Sardegna": "https://www.sardegnaambiente.it/servizi/allertediprotezionecivile/",
            "Sicilia": "https://www.protezionecivilesicilia.it/it/",
            "Toscana": "https://www.cfr.toscana.it/",
            "Trentino-Alto Adige": "https://allerte.provincia.bz.it/",
            "Umbria": "https://www.cfumbria.it/",
            "Valle d'Aosta": "https://cf.regione.vda.it/",
            "Veneto": "https://www.arpa.veneto.it/bollettini/meteo60gg/prociv.php",
            "Italia (Visione nazionale)": "http://www.protezionecivile.gov.it/attivita-rischi/meteo-idro/attivita/previsione-prevenzione/centro-funzionale-centrale-rischio-meteo-idrogeologico"
        }
        
        st.warning("üìä Monitoraggio idrogeologico in tempo reale")
        
        # Dati idrogeologici (esempio statico)
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("Livello idrometrico", "1.8 m", "-0.2 m")
            st.metric("Precipitazioni ultime 24h", "25 mm", "+5 mm")
        
        with col2:
            st.metric("Rischio frane", "Moderato", "stabile")
            st.metric("Saturazione suolo", "65%", "+10%")
        
        # Allerta idrogeologica per regione (esempio statico)
        st.subheader("üö® Allerta idrogeologica")
        
        if regione_scelta == "Liguria":
            st.warning("‚ö†Ô∏è Allerta GIALLA per temporali e rischio idrogeologico in corso")
        elif regione_scelta == "Emilia-Romagna":
            st.warning("‚ö†Ô∏è Allerta GIALLA per piene dei fiumi nelle zone della pianura")
        elif regione_scelta == "Calabria":
            st.warning("‚ö†Ô∏è Allerta GIALLA per rischio idrogeologico nella fascia tirrenica")
        elif regione_scelta == "Campania":
            st.warning("‚ö†Ô∏è Allerta GIALLA per temporali e rischio idrogeologico")
        else:
            st.success("‚úÖ Nessuna allerta idrogeologica attiva")
            
        # Info bollettini
        st.info(f"Ultimo bollettino idrogeologico aggiornato: {datetime.now().strftime('%d/%m/%Y')}")
        
        # Visualizza informazioni sui portali ufficiali
        with st.expander("üîó Portali ufficiali monitoraggio idrogeologico"):
            if regione_scelta in regione_link:
                st.markdown(f"[Centro Funzionale {regione_scelta}]({regione_link[regione_scelta]})")
                
                # Aggiungiamo info aggiuntive sul monitoraggio nazionale
                st.markdown("""
                ### üîó Portali nazionali monitoraggio idrogeologico
                - [Protezione Civile - Centro Funzionale Centrale](http://www.protezionecivile.gov.it/attivita-rischi/meteo-idro/attivita/previsione-prevenzione/centro-funzionale-centrale-rischio-meteo-idrogeologico)
                - [Servizio Meteorologico dell'Aeronautica Militare](http://www.meteoam.it/)
                - [ISPRA - Istituto Superiore per la Protezione e la Ricerca Ambientale](https://www.isprambiente.gov.it/)
                """)
    


def show_monitoraggio_idrogeologico():
    st.subheader("üìä Monitoraggio idrogeologico - Italia (Visione nazionale)")
    
    st.markdown("### üìà Monitoraggio idrogeologico in tempo reale")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.metric("Zone a rischio frana", "1.281.970", "Alta criticit√†")
        st.metric("Comuni interessati", "7.275", "su 7.904 totali")
    
    with col2:
        st.metric("Zone a rischio alluvione", "2.062.475", "Alta criticit√†")
        st.metric("Popolazione esposta", "6.8 M", "abitanti")
    
    st.info("Dati aggiornati al: " + datetime.now().strftime("%d/%m/%Y %H:%M:%S"))
    
    # Mappa delle zone a rischio
    st.markdown("### üó∫Ô∏è Mappa delle zone a rischio")
    st.image("https://idrogeo.isprambiente.it/app/iffi/images/Italia_pericolosita.jpg", 
             caption="Mappa della pericolosit√† da frana in Italia")
